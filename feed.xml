<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>electro·pizza</title>
  
  <subtitle>Chaotic Ramblings</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://electro.pizza/"/>
  <updated>2018-02-13T14:35:37.117Z</updated>
  <id>https://electro.pizza/</id>
  
  <author>
    <name>Ryan Oles</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Geek Spinner Build</title>
    <link href="https://electro.pizza/2018/02/geek-spinner/"/>
    <id>https://electro.pizza/2018/02/geek-spinner/</id>
    <published>2018-02-13T02:26:26.000Z</published>
    <updated>2018-02-13T14:35:37.117Z</updated>
    
    <content type="html"><![CDATA[<p>My nephews are fascinated with fidgit spinners.  They each own several and always have one on hand, proudly showing off the various tricks they have mastered. So when I stumbled across a persistence of vision (pov) fidget spinner <a href="http://www.instructables.com/id/Geek-Spinner/" target="_blank" rel="noopener">project on instructables</a>, I knew that I had my nephews’ 2017 Christmas gifts in the bag.</p><img src="/2018/02/geek-spinner/electro-spinner.gif" title="Frame rates, amiright?"><p>Ken over at <a href="http://www.makersbox.us/" target="_blank" rel="noopener">The Maker’s Box</a> did a fantastic job with <a href="http://www.instructables.com/id/Geek-Spinner/" target="_blank" rel="noopener">documentation</a>, even offering a <a href="https://www.tindie.com/products/MakersBox/programmable-pov-fidget-spinner/" target="_blank" rel="noopener">tindie kit</a> to take the pain out of sourcing components. I took a few pictures while assembling the project, as well as discovering a few tips and alternatives for the build, so I figure it was worth a build log.</p><h2 id="Build-Tips"><a href="#Build-Tips" class="headerlink" title="Build Tips"></a>Build Tips</h2><h3 id="Solder-the-Bearing-Before-the-Components"><a href="#Solder-the-Bearing-Before-the-Components" class="headerlink" title="Solder the Bearing Before the Components"></a>Solder the Bearing Before the Components</h3><p>Perhaps the trickiest part of this build is soldering the bearing onto the board. The board needs to be centered vertically on the bearing, so you’ll need some kind of spacer to hold the board up while you solder. The build instructions suggest using a couple of coins for this task.  This works well enough, however it is also suggested that the bearing is the last thing to solder to the board. I followed this method when building the first spinner, and I found it difficult to balance the coins beneath the board.  The components kept getting in the way, so for the last two boards I decided to place the bearing first. This made things much easier.</p><img src="/2018/02/geek-spinner/bearing-solder.png" title="Much easier with no componenets."><p>I soldered two locations on the top and two rotated 90 degrees on the bottom of the board. There is so much thermal conductivity in the metal of the bearing that you will need to crank up the temperature of your soldering iron to make this job easier.</p><img src="/2018/02/geek-spinner/bearing-inplace.png" title="Got em in there."><h3 id="Alternative-Parts"><a href="#Alternative-Parts" class="headerlink" title="Alternative Parts"></a>Alternative Parts</h3><h4 id="Texas-Instruments-DRV5023"><a href="#Texas-Instruments-DRV5023" class="headerlink" title="Texas Instruments DRV5023"></a>Texas Instruments DRV5023</h4><p>When ordering components for the board, the specified hall effect sensor (the <a href="https://www.digikey.com/product-detail/en/melexis-technologies-nv/MLX92231LUA-AAA-020-SP/MLX92231LUA-AAA-020-SP-ND/" target="_blank" rel="noopener">Melexis MLX92231</a>) was out of stock.  After some looking around and comparing datasheets I decided to give the <a href="https://www.digikey.com/product-detail/en/texas-instruments/DRV5023AJQLPGM/296-41080-1-ND" target="_blank" rel="noopener">Texas Instruments DRV5023</a> a try.  It wound up working fine, and is suitable as a drop-in replacement. Remeber to test the orientation of your magnet!</p><h4 id="Bearing-Caps-from-Amazon"><a href="#Bearing-Caps-from-Amazon" class="headerlink" title="Bearing Caps from Amazon"></a>Bearing Caps from Amazon</h4><p>The initial build specifies 3D printed bearing caps. At present I don’t have a 3D printer at my disposal, so I had to look for alternatives.  I took a chance on some <a href="http://a.co/d8O1pVm" target="_blank" rel="noopener">simple bearing caps</a> I came across on Amazon.  They wound up working fairly well, however they are quite thin, making it difficult to glue in a magnet.  After some thought, I decided to drill out a hole (slightly smaller than the diameter of the magnet) in the bearing cap and press fit the magnet into the cap.  Overall I’m pleased with the solution.</p><h3 id="Misc-Notes"><a href="#Misc-Notes" class="headerlink" title="Misc Notes"></a>Misc Notes</h3><p>The minimum order from Osh Park is three boards, however I only needed two spinners as gifts. This gave me the opportunity to build a third spinner as an initial testing/prototyping device. On the extra board I socketed the chip so that I could easily swap the ATTiny in and out.  This allows me to use a programmer shield I built a while back, and then reseat the chip into the socketed spinner to see how things looked.  It wound up being very helpful in making sure everything in the program looked just right, and in the end I was really glad I built the third spinner.</p><img src="/2018/02/geek-spinner/programmer.gif" title="Free range, artisnal Atmel programming shield."><p>In this shot you can see the press fit magnet in the bearing inserts from Amazon.</p><p>Aside from the bearings and magnet placement, this is a very straight forward build. It would be a great project for anyone new to soldering and wanting more practice. Overall the whole build took me about an hour at a very casual pace.</p><div class="video-container"><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/Sg0XIFQuFHA?rel=0&amp;showinfo=0" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;My nephews are fascinated with fidgit spinners.  They each own several and always have one on hand, proudly showing off the various trick
      
    
    </summary>
    
    
      <category term="arduino" scheme="https://electro.pizza/tags/arduino/"/>
    
      <category term="pov" scheme="https://electro.pizza/tags/pov/"/>
    
      <category term="build log" scheme="https://electro.pizza/tags/build-log/"/>
    
  </entry>
  
  <entry>
    <title>Serial Punch</title>
    <link href="https://electro.pizza/2017/11/punch-python-serial/"/>
    <id>https://electro.pizza/2017/11/punch-python-serial/</id>
    <published>2017-11-12T01:07:02.000Z</published>
    <updated>2017-11-13T03:28:25.790Z</updated>
    
    <content type="html"><![CDATA[<p>In my daily work I use a CLI tool called <a href="http://todotxt.org/" target="_blank" rel="noopener">todo.txt</a> coupled with an add-on called <a href="https://github.com/adewinter/punch" target="_blank" rel="noopener">punch</a> to track the time spent on chunks of work. Tasks are added and organized by todo.txt, and punch is used to punch in and out of those tasks. Additionally, punch has a few useful reporting and archiving functions.  In combination, todo.txt and punch make for a simple and useful tool that has served me well for several years.</p><p>Useful, but not perfect. A big drawback of punch is that there is no obvious indicator of the timer’s state. To see if the timer is active and the elapsed time, you must issue a cli command. Because of this, I often find myself forgetting to punch in to a new task or out at the end of the day. This obviously leads to some inaccuracies and frustrations in my time keeping. I’ve seen a few solutions to this. The simplest solution would likely be some sort of widget to display the running timer somewhere on your windows manager. However, while messing around with some old <a href="/2017/09/panaplex-testing/" title="panaplex displays">panaplex displays</a>, I began thinking of using them in a small desktop clock build.  This clock could potentially have a serial input which would allow it to display information from the punch timer. So I’ve found myself thinking about what would it take to implement something like this.</p><h2 id="CP2104"><a href="#CP2104" class="headerlink" title="CP2104"></a>CP2104</h2><img src="/2017/11/punch-python-serial/CP2104.png" title="CP2104"><p>Last year I was interested in finding a solution for simple USB to serial communications. Through that research I stumbled upon the <a href="https://www.silabs.com/products/interface/usb-bridges" target="_blank" rel="noopener">CP21x devices</a> from Silicon Labs. Eventually I settled on the <a href="https://www.silabs.com/documents/public/data-sheets/cp2104.pdf" target="_blank" rel="noopener">CP2104 USB to UART bridge</a> and ordered a development board. These chips save a lot of work establishing onboard USB.  They appear to an OS as a typical USB device, auto negotiate baud, and simply pass along serial communications to and from the USB port.  There are some advanced configurations available to you if you wish, but by in large the CP2104 is a plug and play chip.</p><p>At the time I wrote a <a href="https://github.com/rh0/cp2104_lcd_test" target="_blank" rel="noopener">test in Python</a> to echo keypresses from my computer to the device. It turns out the chip is as easy to use as promised, and is a perfect solution to interface my computer with a microcontroller in a potential desktop clock.</p><video src="/2017/11/punch-python-serial/cp2104-test.mp4" type="video/mp4" autoplay loop muted></video><h2 id="Python-PoC"><a href="#Python-PoC" class="headerlink" title="Python PoC"></a>Python PoC</h2><p>I thought it would be worthwhile to write a short proof of concept to output data from punch to serial USB. To display this data I used a SparkFun serLCD I had laying around. This wound up being a relatively simple task. I don’t think its useful walking through all of the code, but for the sake of my memory I want to point out a couple things that I learned along the way. If you’re curious you can check out the <a href="https://github.com/rh0/pySerialPunch" target="_blank" rel="noopener">complete script on my github</a>.  Please forgive my clumbsy Python. The code can be cleaned up and there is certainly a more elegant solution.</p><video src="/2017/11/punch-python-serial/punch-serial-demo.mp4" type="video/mp4" autoplay loop muted></video><h3 id="Watchdog"><a href="#Watchdog" class="headerlink" title="Watchdog"></a>Watchdog</h3><p>Punch writes tasks and timestamps to a file, called <code>punch.dat</code> to catalogue time spent on tasks.  In order for my program to be aware of active tasks and elapsed time, it needs to watch this file for changes.  The <a href="https://pythonhosted.org/watchdog/" target="_blank" rel="noopener">Watchdog</a> library handled this task nicely.</p><p>Watchdog establishes an API to monitor file system CRUD events. After digging in a bit, I found it to be friendly and effective, and can be summarized in a few lines of code:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">eventHandler = PunchDatEvent()</span><br><span class="line">observer = Observer()</span><br><span class="line">observer.schedule(eventHandler, <span class="string">'/path/to/watch'</span>)</span><br><span class="line">observer.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># When you're done watching.</span></span><br><span class="line">observer.stop()</span><br></pre></td></tr></table></figure></p><p>Observer is a thread class to which you can schedule monitoring of a given path, and assign it an event handler to act on filesystem CRUD events observed in the given directory. Starting and stopping this thread is as easy as firing the respective methods. Most of the heavy lifting is handled by the event handler you extend from the included <code>FileSystemEventHandler</code> class (<code>PunchDatEvent</code> in the above snippet). Watchdog handles everything else. Quite nice.</p><h3 id="Threading"><a href="#Threading" class="headerlink" title="Threading"></a>Threading</h3><p>A thread has been established for the Watchdog observer to handle filesystem monitoring, but what about the serial communications?  While I could likely handle this in the main program loop, I thought it could be a good opportunity to spin off another thread just for this purpose.  Painful memories linger of C/C++ multithreading from days gone by, but I have no experience with it in Python. The task here seemed simple enough to dip a toe in and give it a try.</p><p>After spending some time with the core <a href="https://docs.python.org/3/library/threading.html" target="_blank" rel="noopener">threading</a> library documentation I was surprised to see just how simple this could be (granted this is a very basic application). To sum up in a couple of lines:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tickTockThread = Thread(target=eventHandler.tickTock)</span><br><span class="line">tickTockThread.start()</span><br></pre></td></tr></table></figure></p><p>Instantiate a thread object and give it a target object to run.  In this case the target is a method I’ve defined within the same event handler used with the observer thread. Then simply start it.  It will run until the target method terminates, at which time the thread is destroyed.</p><p>Reading through the docs, I can see how this can get more complex in a hurry. However, I was pleasantly surprised with how simple this was for my small task.</p><h2 id="Fine-for-now…"><a href="#Fine-for-now…" class="headerlink" title="Fine, for now…"></a>Fine, for now…</h2><p>I now have a decent mechanism for sending my time tracker data via serial over USB to an eventual desk clock.  There are a few critical things to add to the code as I move forward with the project, such as:</p><ul><li>Daemonize the script for Systemd.</li><li>Establish some methods of detecting the presence of the USB device.</li><li>Rework the serial packets sent to fit whatever protocol is eventually used for the clock, rather than the one built into serLCD.</li></ul><p>However, for now, this is fine.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In my daily work I use a CLI tool called &lt;a href=&quot;http://todotxt.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;todo.txt&lt;/a&gt; coupled with an add-on
      
    
    </summary>
    
    
      <category term="todo.txt" scheme="https://electro.pizza/tags/todo-txt/"/>
    
      <category term="python" scheme="https://electro.pizza/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Panaplex Display Testing</title>
    <link href="https://electro.pizza/2017/09/panaplex-testing/"/>
    <id>https://electro.pizza/2017/09/panaplex-testing/</id>
    <published>2017-09-28T03:17:41.000Z</published>
    <updated>2017-09-28T03:17:41.880Z</updated>
    
    <content type="html"><![CDATA[<p>In the Spring of 2017 I attended the <a href="http://hamvention.org/" target="_blank" rel="noopener">Dayton Hamvention</a>. While browsing through piles of random electronics at the flea market, I stumbled upon a few interesting vintage displays. Among these were pairs of 3-digit, 7-segment panaplex displays. While I recognized the unique metallic segments in these displays from their use in old gas pumps and pinball machines, I knew very little about them. That being said, what better way to understand a panaplex than to attempt to drive it? I purchased a pair.</p><img src="/2017/09/panaplex-testing/pan-lit.png" title="Panaplex Display"><h2 id="What-is-a-Panaplex"><a href="#What-is-a-Panaplex" class="headerlink" title="What is a Panaplex?"></a>What is a Panaplex?</h2><p>Knowing nothing about the requirements of this display, a bit of research was in order. Panaplex is a type of gas-plasma display; they work much like the coveted <a href="https://en.wikipedia.org/wiki/Nixie_tube" target="_blank" rel="noopener">nixie tubes</a>. A small chamber is filled with low pressure neon gas. Within the gas filled chamber there is a single common anode, and multiple wire cathodes making up the segments of a digit.  When sufficient power is supplied to the cathodes, they will light up with an orange plasma glow. Panaplex saw widespread use from the 1970’s through the 1990’s, but fell in popularity when low power super-effecient LED displays became ubiquitous.</p><img src="/2017/09/panaplex-testing/pan-split.png" title="Panaplex Closeup"><p>The particular displays I picked up (pictured above) have “Beckman SP-353” etched in the glass on the bottom left corner. As luck would have it, the internet yeilded a <a href="/2017/09/panaplex-testing/beckman-sperry.pdf">datasheet</a> for the very same model. I found it listed in the <a href="http://www.tube-tester.com/sites/nixie/dat_arch.htm" target="_blank" rel="noopener">tube-tester.com archive</a>.</p><img src="/2017/09/panaplex-testing/sp-353_detail.png" title="SP-353 Detail"><p>The datasheet revealed what it would take to get this thing glowing. A supply voltage of 160Vdc (minimum) drawing about 330μA would do the trick.</p><p>Wait, 160 Volts minimum?!</p><p>My bench top power supply can only produce 30 Volts. How are we going to power these things?</p><h2 id="Boost-Converter"><a href="#Boost-Converter" class="headerlink" title="Boost Converter"></a>Boost Converter</h2><p>The first solution that jumped to mind was a switched-mode power supply (SMPS), specifically a <a href="https://en.wikipedia.org/wiki/Boost_converter" target="_blank" rel="noopener">boost converter</a>. A boost converter will step up a given DC input voltage to a higher output voltage at the cost of stepping down the input current. They are small, cheap, and effecient. Its a great fit for this situation.</p><p>Typically you can find a cheap “good enough” boost converter to fit your needs on ebay, Banggood, or even Amazon. However, after some thorough searching I could not find anything reasonable for voltages as high as this. Attempting to design and build my own SMPS was a possibility.  Their basic function is remarkably simple, but I knew this could quickly lead down a rabbit hole of tuning, testing, and iterating over prototypes. What I needed was an existing solution just to verify these displays were in working order.</p><h3 id="The-de-Smith-SMPS"><a href="#The-de-Smith-SMPS" class="headerlink" title="The de Smith SMPS"></a>The de Smith SMPS</h3><p>After some thought, it dawned on me that nixie tubes have very similar power requirements.  Maybe a solution lurked there. Broadening the search a bit, I started looking through nixie hobbiest communities to see what their solutions were. The “de Smith Power Supply” was frequently mentioned, and after finally landing on <a href="http://www.desmith.net/NMdS/Electronics/NixiePSU.html" target="_blank" rel="noopener">Nick de Smith’s page</a> detailing his solution, I was convinced. The de Smith SMPS takes a 12V - 15V input and boosts to a 150V - 220V output.  He gives a detailed explanation of how his SMPS works, the thoughts behind his design and component choices (including a BoM, complete with digikey callouts), and even catalogues some performance testing results.  On top of all this, he was generous enough to include the Eagle cad files for the board. With this information, all that was left to do was place an order with <a href="https://oshpark.com/" target="_blank" rel="noopener">OSH Park</a> &amp; <a href="https://www.digikey.com/" target="_blank" rel="noopener">Digi-Key</a> and wait.</p><img src="/2017/09/panaplex-testing/pan-desmith.png" title="Not the best solder job, but it" alt="ll work."><p>Everything arrived, and I eagerly populated the components. Now let’s see if this thing works!  I connected my bench power supply to Vcc and GND on the SMPS per de Smith’s instructions.  The bench power supply was set to 14Vdc, and I happily observed around 160Vdc output from the SMPS. There is a small potentiometer on the board that allows you to make adjustments to the <a href="https://www.digikey.com/product-detail/en/maxim-integrated/MAX1771ESA-/MAX1771ESA--ND/947783" target="_blank" rel="noopener">MAX1771</a> switching controller chip, thereby controlling the output voltage. Excellent.</p><img src="/2017/09/panaplex-testing/pan-boost_volt.gif" title="Voltage adjustment"><p>After some fiddling, I dialed the power supply in to around 165V and turned my attention back to the panaplex display.</p><h2 id="Does-it-work"><a href="#Does-it-work" class="headerlink" title="Does it work?"></a>Does it work?</h2><p>Everything up to this point was done just to see if these displays were in working condition.  They seemed to be in good shape and the vendor at the hamvention asssured me they were in working order. However, I had no way to verify these claims in a muddy field in Ohio, nor when I arrived home with a measly 30V bench top supply. So, with boost converter in hand, it was finally time to see if I had a working display.</p><img src="/2017/09/panaplex-testing/pan-pin_sweep.gif" title="HUZZA!"><p>Success!</p><p>I used some small jumper wires to connect the 165V output on the de Smith SMPS to the anode of one of the digits, and all of the cathodes to a pin header on a breadboard.  This allowed me to sweep another jumper, connected to ground, across the header pins to test individual segments. I repeated this for each digit of the display on the two displays I had.  Everything worked as expected, and I found myself basking in the warm plasma glow of nearly 50 year old technology.</p><h2 id="What’s-next"><a href="#What’s-next" class="headerlink" title="What’s next?"></a>What’s next?</h2><p>Now that we know everything is working, the next step is to design and build a board to make these displays more friendly to modern extra low voltage digital controllers (Arduino, Raspberry Pi, Odroid, etc).  I’ve begun narrowing down my transistor selection, and sketched some preliminary scematics in <a href="http://kicad-pcb.org/" target="_blank" rel="noopener">KiCad</a>. However, that will all have to be fodder for a future post.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In the Spring of 2017 I attended the &lt;a href=&quot;http://hamvention.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Dayton Hamvention&lt;/a&gt;. While browsin
      
    
    </summary>
    
    
      <category term="panaplex" scheme="https://electro.pizza/tags/panaplex/"/>
    
      <category term="boost converter" scheme="https://electro.pizza/tags/boost-converter/"/>
    
  </entry>
  
  <entry>
    <title>Beaker Browser and The DAT Protocol</title>
    <link href="https://electro.pizza/2017/09/beaker-dat/"/>
    <id>https://electro.pizza/2017/09/beaker-dat/</id>
    <published>2017-09-17T23:00:00.000Z</published>
    <updated>2017-09-18T17:04:13.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="The-Dat-Protocol"><a href="#The-Dat-Protocol" class="headerlink" title="The Dat Protocol"></a>The Dat Protocol</h2><p><a href="https://datproject.org/" target="_blank" rel="noopener">Dat</a> was developed with the idea of making sharing large files or folders securely an easy task.  Without the need to rely on a central “cloud” service (like dropbox) or through semi-cumbersome means like rsync or scp, Dat can make it easy to store, share, and track large volumes of data.  This is accomplished through a peer-to-peer (p2p) network (much like BitTorrent). This brings along several of the benefits of a p2p architecture.  There is no central host where availability (or security/privacy leanings) would be a concern, you can share across a local network (LAN), and bandwidth scales with the growth of demand as downloads will be distributed across the peers.</p><p>Scientists and researchers were the initial target audience for Dat, allowing them to easily archive and share data. I first caught wind of Dat in Februrary of 2017 when it came to light that the data stored at <a href="open.whitehouse.gov">open.whitehouse.gov</a> was being inexplicably deleted.  Data from open.whitehouse.gov was scraped and stored in a Dat archive so that the information would not be lost. You can see this and a few other endeavors cataloged on <a href="https://datproject.org/explore" target="_blank" rel="noopener">the Dat website</a>.</p><p>You can read more about Dat, and forgo further clumsy explanation from me, in their <a href="https://docs.datproject.org/" target="_blank" rel="noopener">documentation</a>.</p><h2 id="Beaker-Browser"><a href="#Beaker-Browser" class="headerlink" title="Beaker Browser"></a>Beaker Browser</h2><p>So Dat is a protocol to serve files. Viewing a website is nothing more than files served to a browser that then renders them. So what if we pipe files recieved via the Dat protocol to a browser for rendering? Well you got a peer-to-peer web goin’!</p><p>Clearly it’s a bit more complex than that, but that is the gist of what <a href="https://Beakerbrowser.com/" target="_blank" rel="noopener">Beaker Browser</a> does. Beaker is a project developed by <a href="https://twitter.com/taravancil" target="_blank" rel="noopener">Tara Vancil</a> and <a href="https://twitter.com/pfrazee" target="_blank" rel="noopener">Paul Frazee</a>, and is a self described peer-to-peer web browser.  Its still under very active development, but after some semi-regular use I’ve found it both useable and exciting.</p><p>Recently Tara and Paul did a talk for the local group <a href="https://edgeatx.github.io/" target="_blank" rel="noopener">Bleeding Edge Web</a> here in Austin. The talk is enlightening; it gives a window into their vision of the project. If you have some free time, its worth a watch.</p><div class="video-container"><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/9tk9m_QIi2Q?rel=0&amp;start=2810" frameborder="0" allowfullscreen></iframe></div><p>Paul also has a brief video introduction to Beaker:</p><div class="video-container"><iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/U2B9mwRFE8U?rel=0" frameborder="0" allowfullscreen></iframe></div><p>The peer-to-peer web is, arguably, still in its infancy.  However, seeing and using a working model is exciting, with potentially far-reaching ramifications. Since many of the current “gatekeepers” to the web are taken out of the equation in a peer-to-peer model, I think there is a potential to reclaim a lot of the magic and excitement present in the early internet. In this spirit, I’ve made this site available to Beaker via Dat at <a href="dat://electro.pizza">dat://electro.pizza</a> or<br><a href="dat://485d1f5c6cc1970ee29318f3be66c6c9bd0fb5894e757fdc926785ae6a725346" target="_blank" rel="noopener">dat://485d1f5c6cc1970ee29318f3be66c6c9bd0fb5894e757fdc926785ae6a725346</a> if you like hashes.</p><p>While setting this simple site up a few things stood out to me and I’d like to note them here. For the sake of time (and the length of this post), I’m not going to touch on all of the features with both Dat and Beaker. Rather, I will try to limit the focus to what I encountered while setting up and publishing this simple site.  Many of these features are quite interesting and exciting in their own right, and if you are interested I encourage you to check them out on the relavent project pages.  Most notable of these to me are:</p><ul><li>Built in versioning on the history of changes in a DAT site.</li><li>Forking of Dat sites (along with new potential workflows when working with a team).</li><li>New Web API’s in Beaker to build peer-to-peer applications.</li></ul><p>But for now, some Beaker basics:</p><h3 id="Site-Generation"><a href="#Site-Generation" class="headerlink" title="Site Generation"></a>Site Generation</h3><p>Initial creation of a site/hash is extremely simple; the dialogues in the browser walk you through things. Beaker handles setting up the <code>.dat</code> folder and keys behind the scenes so you don’t have to futz with it.  If you don’t want to keep the site code in the default location (<code>/home/&lt;user&gt;/Sites</code> in Linux), you need to take the extra step of changing the directory to point at the public files of your site.</p><p>Here is an example of the process:<br><img src="/2017/09/beaker-dat/new_site-hash.gif" title="Creating a New Site/Hash"></p><h3 id="Live-Reload"><a href="#Live-Reload" class="headerlink" title="Live Reload"></a>Live Reload</h3><p>Live reloading should be nothing new to most web developers, however its nice to have this ready to go “out of the box”.  It behaves like you would expect, watching site files for changes and refreshing.  This makes pairing with something like a static site generator in a watch mode quite nice.</p><img src="/2017/09/beaker-dat/live-reload.gif" title="Live Reloading"><h3 id="Publishing"><a href="#Publishing" class="headerlink" title="Publishing"></a>Publishing</h3><p>This was glossed over in the site generation example above, but the publishing mechanism may be the most exciting (in the context of workflow) with Beaker.  As you would expect, when you make changes to site files locally they are reflected locally in Beaker. Traditionally, when you are ready to publish these changes to the web, you would perform a push of the code through various mechanisms, ie. pushing to a CI system or manually scp/rsync/sftp files to a centralized server somewhere.  However, with Beaker all you need do is click the big green publish button, and the file changes are then propigated through to all peers. No server concerns at all. Refreshing!</p><img src="/2017/09/beaker-dat/publishing.gif" title="Publishing"><p>In this example Beaker is on the left and Firefox on the right. Changes published from Beaker are reflected via a remote peer serving over HTTPS to Firefox.</p><h2 id="dathttpd"><a href="#dathttpd" class="headerlink" title="dathttpd"></a>dathttpd</h2><p>Now wait a minute. Firefox? HTTPS? A *gasp* SERVER!?  Weren’t we talking about a peer-to-peer web? Well we are, but we don’t have a widely adopted peer-to-peer web yet!  So, we need a stop-gap to solve a couple of issues:</p><p>First, electro.pizza isn’t wildly popular. Often my local Beaker Browser installation will be the only peer, thus the only source for anyone to view the site. Therefore, for this site to have constant “uptime”, I would need my Beaker installation to always be running with a network connection.  Not ideal.</p><p>Second, the vast majority of people surfing the web are using more traditional browsers (Firefox, Chrome, Edge, etc.), and I would like those folks to be able to view my site through the (currently) standard HTTPS web protocol.</p><p><a href="https://github.com/Beakerbrowser/dathttpd" target="_blank" rel="noopener">Dathttpd</a> solves this problem by acting as both a peer for a Dat site, as well as a small web server.  This allows you to keep a Dat site up without having to leave Beaker running.  Further, you get the added bonus of being able to point DNS at that server which allows for shortnames for your site.  Configuration is simple and detailed on the projects github page.</p><h3 id="Hangups"><a href="#Hangups" class="headerlink" title="Hangups"></a>Hangups</h3><p>I was caught up in a couple of small snags while setting up dathttpd. Nothing crazy, but its probably worth a note.</p><h4 id="Node-Installation-on-the-Server"><a href="#Node-Installation-on-the-Server" class="headerlink" title="Node Installation on the Server"></a>Node Installation on the Server</h4><p>Once the dathttpd config is set up and things seem to be working as expected, it is suggested to use <a href="https://github.com/mafintosh/add-to-systemd" target="_blank" rel="noopener">add-to-systemd</a> to daemonize the process.  This works quite well, however I’ve found add-to-systemd works best if nodejs is installed on a system level (rather than something like NVM). Use your distro’s package manager to install nodejs greater than version 6.0.  On distros like Ubuntu, you’ll likely have to add a PPA for the newer nodejs version.</p><h4 id="Firewalls"><a href="#Firewalls" class="headerlink" title="Firewalls"></a>Firewalls</h4><p>After having dathttpd running for a few days then returning to Beaker to make site updates, I found that dathttpd and Beaker had trouble reconnecting with each other to propigate updates. I watched traffic for a bit, and it seemed to be a firewall issue with the server. Turns out the machine that is running dathttpd needs to have port 3282/tcp open.  After making this adjustment everything worked as expected. I have a bit of a nagging concern that any machine running Beaker also needs port 3282 opened.  So far this does not seem to be the case, but I’m not completely convinced.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;The-Dat-Protocol&quot;&gt;&lt;a href=&quot;#The-Dat-Protocol&quot; class=&quot;headerlink&quot; title=&quot;The Dat Protocol&quot;&gt;&lt;/a&gt;The Dat Protocol&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https
      
    
    </summary>
    
    
      <category term="Beaker" scheme="https://electro.pizza/tags/Beaker/"/>
    
      <category term="p2p" scheme="https://electro.pizza/tags/p2p/"/>
    
  </entry>
  
</feed>
